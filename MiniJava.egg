----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--              Gestion de la table des symboles
--              Typage
--              Calcul des déplacements (Allocation mémoire)
--              Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;

inh factory	: BlockFactory for Acces, Affectation, Appel, AppelOuAcces, Arguments, ArgumentGenericite,
              ArgumentsGenericite, AttributOuMethode, Bloc, Classe, Classes, Condition, Constructeur, ElementClasse,
              ElementInterface, ElementsClasse, Genericite,ElementsInterface, Expression, Expressions, Facteur,
              HeritageClasse, HeritageGenericite, HeritageInterface, ImplantationInterface,InstanceGenericite,
              Instruction, Instructions, Interface, Interfaces, MethodePrincipale, Parametre, Parametres ,
              ParametreGenericite, ParametresGenericite, Principale, Programme, Signature, SuiteAffectation,
              SuiteArgumentsGenericite, SuiteAttributOuMethode, SuiteCondition, SuiteConditionnelle,
              SuiteExpressions, SuiteFacteur, SuiteHeritageGenericite, SuiteHeritageInterface, SuiteNouveau,
              SuiteParametres, SuiteParametresGenericite, SuiteTerme, SuiteTypeAtomique, Terme, Type, TypeAtomique,
              Valeur;
inh tds     : SymbolTable for   Acces, Affectation, Appel, AppelOuAcces, Arguments, ArgumentGenericite,
              ArgumentsGenericite, AttributOuMethode, Bloc, Classe, Classes, Condition, Constructeur, ElementClasse,
              ElementInterface, ElementsClasse, ElementsInterface, Expression, Expressions, Facteur, Genericite,
              HeritageClasse, HeritageGenericite, HeritageInterface, ImplantationInterface,InstanceGenericite,
              Instruction, Instructions, Interface, Interfaces, MethodePrincipale, Parametre, Parametres,
              ParametreGenericite, ParametresGenericite, Principale, Programme, Signature, SuiteAffectation,
              SuiteArgumentsGenericite, SuiteAttributOuMethode,SuiteCondition, SuiteConditionnelle, SuiteExpressions,
              SuiteFacteur, SuiteHeritageGenericite, SuiteHeritageInterface, SuiteNouveau, SuiteParametres,
              SuiteParametresGenericite, SuiteTerme, Terme , Type, TypeAtomique;
inh support : Expression for AppelOuAcces, Appel, Acces, Arguments;
inh gauche	: Expression for SuiteTerme, SuiteFacteur, SuiteCondition;
inh type    : Type for SuiteTypeAtomique, SuiteNouveau;

syn ast     : Program for Fichier, Programme;
syn ast     : Block for Bloc, SuiteConditionnelle;
syn ast		: Type for  Type, TypeAtomique, SuiteTypeAtomique;
syn ast		: Instruction for Instruction;
syn ast     : List<Instruction> for Instructions;
syn ast		: Expression for Expression, Facteur, SuiteFacteur, SuiteNouveau, Terme, SuiteTerme, Condition,
              SuiteCondition, Acces, Appel, AppelOuAcces, Affectation, SuiteAffectation, Arguments;
syn ast     : List<Expression> for Expressions, SuiteExpressions;
syn ast     : Value for Valeur;
syn ast     : InterfaceDeclaration for Interface;
syn ast     : List<InterfaceDeclaration> for Interfaces;
syn ast     : ClassDeclaration for Classe, Principale;
syn ast     : List<ClassDeclaration> for Classes;
syn ast     : InheritanceDeclaration<ClassDeclaration> for HeritageClasse;
syn ast     : List<InheritanceDeclaration<InterfaceDeclaration>> for ImplantationInterface, HeritageInterface,
              SuiteHeritageInterface;
syn ast     : ClassElement for ElementClasse, ElementInterface, MethodePrincipale;
syn ast     : Declaration for AttributOuMethode;
syn ast     : FunctionDeclaration for Constructeur;
syn ast     : List<ClassElement> for ElementsClasse, ElementsInterface;
syn ast     : SignatureDeclaration for Signature;
syn ast     : GenericParameter for ParametreGenericite;
syn ast     : List<GenericParameter> for Genericite, ParametresGenericite, SuiteParametresGenericite;
syn ast     : AccessModifier for DroitAcces;
syn ast     : ParameterDeclaration for Parametre;
syn ast     : List<ParameterDeclaration> for Parametres, SuiteParametres, SuiteAttributOuMethode;
syn ast     : List<GenericType> for InstanceGenericite, ArgumentsGenericite, SuiteArgumentsGenericite,
              HeritageGenericite, SuiteHeritageGenericite;
syn ast     : GenericType for ArgumentGenericite;
syn bin_op	: BinaryOperator for Additif, Multiplicatif, Comparatif;
syn type    : ClassElementType for SuiteAttributOuMethode;
syn body    : FunctionBody for SuiteAttributOuMethode;
syn value   : Expression for SuiteAttributOuMethode;



space separateur				is    "[\n\r\t ]+";
space commentaire		    	is    "\/\/.*\n";
sugar accolade_ouvrante		    is    "\{";
sugar accolade_fermante	    	is    "\}";
sugar crochet_ouvrant			is    "\[";
sugar crochet_fermant			is    "\]";
sugar parenthese_ouvrante		is    "\(";
sugar parenthese_fermante		is    "\)";
sugar inferieur		    		is    "\<";
sugar superieur			    	is    "\>";
sugar inferieur_egal			is    "\<=";
sugar superieur_egal			is    "\>=";
sugar point					    is    "\.";
sugar point_virgule	    		is    ";";
sugar virgule					is    ",";
sugar affectation				is    "=";
sugar egalite					is    "==";
sugar different			    	is    "\!=";
sugar addition			    	is    "\+";
sugar soustraction				is    "\-";
sugar ou						is    "\|\|";
sugar multiplication			is    "\*";
sugar division			    	is    "/";
sugar modulo			   		is    "%";
sugar adresse					is    "&";
sugar negation			    	is    "\!";
sugar et						is    "&&";
sugar vrai			    		is    "true";
sugar faux			    		is    "false";
sugar si						is    "if";
sugar sinon					    is    "else";
sugar afficher					is    "print";
sugar nouveau			    	is    "new";
sugar tant_que			    	is    "while";
sugar retour					is    "return";
sugar type_int			    	is    "int";
sugar type_bool 				is    "boolean";
sugar type_char	    			is    "char";
sugar type_String				is    "String";
sugar vide			    		is    "void";
sugar nul						is    "null";
sugar choix		    			is    "\?";
sugar deux_points				is    ":";
sugar interface		    		is    "interface";
sugar classe					is    "class";
sugar extension	    			is    "extends";
sugar implantation				is    "implements";
sugar public					is    "public";
sugar protege					is    "protected";
sugar prive				    	is    "private";
sugar statique					is    "static";
sugar final				    	is    "final";
sugar principale				is    "main";
sugar ceci      				is    "this";
term  chaine					is    "\"([^\"]|\\\")*\"";
term  caractere			    	is    "\'[^\']\'";
term  entier					is    "[0-9]+";
term  identificateur			is    "[a-z_][a-zA-Z0-9_]*";
term  identificateur_type		is    "[A-Z][a-zA-Z0-9_]*";


Fichier -> #inh Programme #ast;
#inh {
do
   Programme^factory := new BlockFactoryImpl();
   Programme^tds := new SymbolTable();
end
}
#ast {
do
    Fichier^ast := Programme^ast;
end
}

Programme -> #inh1 Interfaces Classes Principale #ast;
#inh1 {
do
   Interfaces^tds := Programme^tds;
   Classes^tds := Programme^tds;
   Principale^tds := Programme^tds;
end
}
#ast {
do
   Programme^ast := Programme^factory.createProgram(
                        Interfaces^ast, Classes^ast, Principale^ast
                    );
end
}


Interfaces -> Interface #inh Interfaces #ast;
#inh {
do
    if !Interfaces^tds.knows(Interface^ast.getName()) then
        Interfaces^tds.register(Interface^ast);
        Interfaces1^tds := Interfaces^tds;
    else
          error(MiniJava_Interface_Override, Interface^ast);
    end
end
}
#ast {
do
    Interfaces1^ast.add(0, Interface^ast);
    Interfaces^ast := Interfaces1^ast;
end
}

Interfaces -> #ast;
#ast {
do
    Interfaces^ast := new LinkedList<InterfaceDeclaration>();
end
}


Interface -> interface identificateur_type #inh Genericite HeritageInterface accolade_ouvrante ElementsInterface accolade_fermante #ast;
#inh {
do
    Genericite^tds := Interface^tds;
    HeritageInterface^tds := Interface^tds;
    ElementsInterface^tds := new SymbolTable(Interface^tds);
end
}
#ast {
do
    Interface^ast := Interface^factory.createInterfaceDeclaration(
                       identificateur_type^txt,
                       Genericite^ast,
                       HeritageInterface^ast,
                       ElementsInterface^ast
                     );
end
}


HeritageInterface -> extension identificateur_type InstanceGenericite #inh SuiteHeritageInterface #ast;
#inh {
do
    if HeritageInterface^tds.knows(identificateur_type^txt) then
        SuiteHeritageInterface^tds := HeritageInterface^tds;
    else
        error(MiniJava_Interface_Inheritance, identificateur_type^txt);
    end
end
}
#ast {
local
    oid : Optional<Declaration>;
    intd: Declaration;
do
    oid := HeritageInterface^tds.get(identificateur_type^txt);
    intd := oid.get();
    match intd
    with InterfaceDeclaration then
        SuiteHeritageInterface^ast.add(0, HeritageInterface^factory.createInheritanceDeclaration(
                                                intd, InstanceGenericite^ast));
        HeritageInterface^ast := SuiteHeritageInterface^ast;
    end
end
}

HeritageInterface -> #ast;
#ast {
do
    HeritageInterface^ast := new LinkedList<InheritanceDeclaration<InterfaceDeclaration>>();
end
}


SuiteHeritageInterface -> virgule identificateur_type InstanceGenericite #inh SuiteHeritageInterface #ast;
#inh {
do
    if SuiteHeritageInterface^tds.knows(identificateur_type^txt) then
        SuiteHeritageInterface1^tds := SuiteHeritageInterface^tds;
    else
          error(MiniJava_Interface_Inheritance, identificateur_type^txt);
    end
end
}
#ast {
local
    oid : Optional<Declaration>;
    intd: Declaration;
do
    oid := SuiteHeritageInterface^tds.get(identificateur_type^txt);
    intd := oid.get();
    match intd
    with InterfaceDeclaration then
        SuiteHeritageInterface1^ast.add(0, SuiteHeritageInterface^factory.createInheritanceDeclaration(
                                                intd, InstanceGenericite^ast));
        SuiteHeritageInterface^ast := SuiteHeritageInterface1^ast;
    end
end
}

SuiteHeritageInterface -> #ast;
#ast {
do
    SuiteHeritageInterface^ast := new LinkedList<InheritanceDeclaration<InterfaceDeclaration>>();
end
}

ElementsInterface -> ElementInterface #inh ElementsInterface #ast;
#inh {
do
    if !ElementsInterface^tds.knows(ElementInterface^ast.getName()) then
        ElementsInterface^tds.register(ElementInterface^ast);
        ElementsInterface1^tds := ElementsInterface^tds;
    else
          error(MiniJava_Interface_Inheritance, ElementInterface^ast);
    end
end
}
#ast {
do
    ElementsInterface1^ast.add(0, ElementInterface^ast);
    ElementsInterface^ast := ElementsInterface1^ast;
end
}

ElementsInterface -> #ast;
#ast {
do
    ElementsInterface^ast := new LinkedList<ClassElement>();
end
}


ElementInterface -> final statique Type identificateur affectation Expression point_virgule #ast;
#ast {
do
    ElementInterface^ast := ElementInterface^factory.createClassElement(
        ElementInterface^factory.createVariableDeclaration(identificateur^txt, Type^ast, Expression^ast),
        AccessModifier.Public,
        NonAccessModifier.Final,
        NonAccessModifier.Static
    );
end
}

ElementInterface -> Signature point_virgule #ast;
#ast {
do
    ElementInterface^ast := ElementInterface^factory.createClassElement(
        Signature^ast, AccessModifier.Public
    );
end
}

Signature -> vide identificateur parenthese_ouvrante #inh Parametres parenthese_fermante #ast;
#inh {
do
    Parametres^tds := new SymbolTable(Signature^tds);
end
}
#ast {
do
    Signature^ast := Signature^factory.createSignature(identificateur^txt, AtomicType.VoidType, Parametres^ast);
end
}

Signature -> Type identificateur parenthese_ouvrante #inh Parametres parenthese_fermante #ast;
#inh {
do
    Parametres^tds := new SymbolTable(Signature^tds);
end
}
#ast {
do

    Signature^ast := Signature^factory.createSignature(identificateur^txt, Type^ast, Parametres^ast);
end}


Classes -> Classe #inh Classes #ast;
#inh {
do
    if !Classes^tds.knows(Classe^ast.getName()) then
        Classes^tds.register(Classe^ast);
        Classes1^tds := Classes^tds;
    else
          error(MiniJava_Classe_Override, Classe^ast);
    end
end
}
#ast {
do
    Classes1^ast.add(0, Classe^ast);
    Classes^ast := Classes1^ast;
end
}

Classes -> #ast;
#ast {
do
    Classes^ast := new LinkedList<ClassDeclaration>();
end
}


Classe -> classe identificateur_type Genericite HeritageClasse #inh ImplantationInterface accolade_ouvrante
ElementsClasse accolade_fermante #ast;
#inh {
local
    s : SymbolTable;
    h : ClassDeclaration;
    he: List<ClassElement>;
do
    s := new SymbolTable(Classe^tds);
    if HeritageClasse^ast != null then
        h := HeritageClasse^ast.getDeclaration();
        he:= h.getHeritableElements();
        ElementsClasse^tds := new SymbolTable(Classe^factory.addInheritedElements(s, he));
    else
        ElementsClasse^tds := s;
    end
end
}
#ast {
do
    Classe^ast := Classe^factory.createClassDeclaration(
                       identificateur_type^txt,
                       Genericite^ast,
                       HeritageClasse^ast,
                       ImplantationInterface^ast,
                       ElementsClasse^ast
                     );
end
}

HeritageClasse -> extension identificateur_type InstanceGenericite #ast;
#ast {
local
    ocd : Optional<Declaration>;
    cd : Declaration;
do
    if HeritageClasse^tds.knows(identificateur_type^txt) then
        ocd := HeritageClasse^tds.get(identificateur_type^txt);
        cd := ocd.get();
        match cd
        with ClassDeclaration then
            HeritageClasse^ast := HeritageClasse^factory.createInheritanceDeclaration(cd, InstanceGenericite^ast);
        end
    else
        error(MiniJava_Type_not_defined, identificateur_type^txt);
    end
end
}

HeritageClasse -> #ast;
#ast {
do
    HeritageClasse^ast := null;
end
}

ImplantationInterface -> implantation identificateur_type InstanceGenericite #inh SuiteHeritageInterface #ast;
#inh {
do
    if ImplantationInterface^tds.knows(identificateur_type^txt) then
        SuiteHeritageInterface^tds := ImplantationInterface^tds;
    else
          error(MiniJava_Interface_Inheritance, identificateur_type^txt);
    end
end
}
#ast {
local
    oid : Optional<Declaration>;
    intd: Declaration;
do
    if ImplantationInterface^tds.knows(identificateur_type^txt) then
        oid := ImplantationInterface^tds.get(identificateur_type^txt);
        intd := oid.get();
        match intd
        with InterfaceDeclaration then
            SuiteHeritageInterface^ast.add(0, ImplantationInterface^factory.createInheritanceDeclaration(
                                                intd, InstanceGenericite^ast));
            ImplantationInterface^ast := SuiteHeritageInterface^ast;
        end
    else
        error(MiniJava_Interface_Inheritance, identificateur_type^txt);
    end
end
}

ImplantationInterface -> #ast;
#ast {
do
    ImplantationInterface^ast := new LinkedList<InheritanceDeclaration<InterfaceDeclaration>>();
end
}


Principale -> public classe identificateur_type accolade_ouvrante MethodePrincipale accolade_fermante #ast;
#ast {
do
    Principale^ast := Principale^factory.createClassDeclaration(identificateur_type^txt, MethodePrincipale^ast);
end
}
--
--
MethodePrincipale -> public statique vide principale parenthese_ouvrante type_String crochet_ouvrant crochet_fermant identificateur parenthese_fermante Bloc #ast;
#ast {
local
    st    : Type;
    param : ParameterDeclaration;
    params: List<ParameterDeclaration>;
    body  : FunctionBody;
    main  : FunctionDeclaration;
do
    st := MethodePrincipale^factory.createArrayType(AtomicType.StringType);
    param := MethodePrincipale^factory.createParameterDeclaration(identificateur^txt, st);
    params := new LinkedList<ParameterDeclaration>();
    --TODO: because there is no entry no parameter is needed for main method
    --params.add(0, param);
    body := MethodePrincipale^factory.createFunctionBody(Bloc^ast);
    main := MethodePrincipale^factory.createFunctionDeclaration("main", AtomicType.VoidType, params, body);
    MethodePrincipale^ast := MethodePrincipale^factory.createClassElement(main, AccessModifier.Public,
    NonAccessModifier.Static);
end
}


Genericite -> inferieur ParametresGenericite superieur #ast;
#ast {
do
    Genericite^ast := ParametresGenericite^ast;
end
}

Genericite -> #ast;
#ast {
do
    Genericite^ast := new LinkedList<GenericParameter>();
end
}

ParametresGenericite -> ParametreGenericite #inh SuiteParametresGenericite #ast;
#inh {
do
    if !ParametresGenericite^tds.knows(ParametreGenericite^ast.getName()) then
        ParametresGenericite^tds.register(ParametreGenericite^ast);
        SuiteParametresGenericite^tds := ParametresGenericite^tds;
    else
          error(MiniJava_ParametreGenericite_Definition, ParametreGenericite^ast);
    end
end
}
#ast {
do

    SuiteParametresGenericite^ast.add(0, ParametreGenericite^ast);
    ParametresGenericite^ast := SuiteParametresGenericite^ast;
end
}


SuiteParametresGenericite -> virgule ParametreGenericite #inh SuiteParametresGenericite #ast;
#inh {
do
    if !SuiteParametresGenericite^tds.knows(ParametreGenericite^ast.getName()) then
        SuiteParametresGenericite^tds.register(ParametreGenericite^ast);
        SuiteParametresGenericite1^tds := SuiteParametresGenericite^tds;
    else
          error(MiniJava_ParametreGenericite_Definition, ParametreGenericite^ast);
    end
end
}
#ast {
do
    SuiteParametresGenericite1^ast.add(0,(ParametreGenericite^ast));
    SuiteParametresGenericite^ast := SuiteParametresGenericite1^ast;
end
}

SuiteParametresGenericite -> #ast;
#ast {
do
    SuiteParametresGenericite^ast := new LinkedList<GenericParameter>();
end
}

ParametreGenericite -> identificateur_type HeritageGenericite #ast;
#ast {
do
    ParametreGenericite^ast := ParametreGenericite^factory.createGenericParameter(
                                    identificateur_type^txt, HeritageGenericite^ast);
end
}

--TODO: Wildcard Genericite
--ArgumentGenericite -> choix HeritageGenericite ;


HeritageGenericite -> extension identificateur_type InstanceGenericite SuiteHeritageGenericite #ast;
#ast {
local
    ot : Optional<Declaration>;
    d  : Declaration;
    t  : Type;
    gt : GenericType;
do
    if !HeritageGenericite^tds.knows(identificateur_type^txt) then
        ot := HeritageGenericite^tds.get(identificateur_type^txt);
        d  := ot.get();
        t  := d.getType();
        gt := HeritageGenericite^factory.createGenericType(t, InstanceGenericite^ast);
        SuiteHeritageGenericite^ast.add(0, gt);
        HeritageGenericite^ast := SuiteHeritageGenericite^ast;
    else
        error(MiniJava_Type_Error, identificateur_type^txt);
    end
end
}

HeritageGenericite -> #ast;
#ast{
do
    HeritageGenericite^ast := new LinkedList<GenericType>();
end
}

SuiteHeritageGenericite -> adresse identificateur_type InstanceGenericite SuiteHeritageGenericite #ast;
#ast {
local
    ot : Optional<Declaration>;
    d  : Declaration;
    t  : Type;
    gt : GenericType;
do
    if !SuiteHeritageGenericite^tds.knows(identificateur_type^txt) then
        ot := SuiteHeritageGenericite^tds.get(identificateur_type^txt);
        d  := ot.get();
        t  := d.getType();
        gt := SuiteHeritageGenericite^factory.createGenericType(t, InstanceGenericite^ast);
        SuiteHeritageGenericite1^ast.add(0, gt);
        SuiteHeritageGenericite^ast := SuiteHeritageGenericite1^ast;
    else
        error(MiniJava_Type_Error, identificateur_type^txt);
    end
end
}

SuiteHeritageGenericite -> #ast;
#ast{
do
    SuiteHeritageGenericite^ast := new LinkedList<GenericType>();
end
}


--TODO (Instance Genericite)
InstanceGenericite -> #ast;
#ast {
do
    InstanceGenericite^ast := new LinkedList<GenericType>();
end
}

InstanceGenericite -> inferieur ArgumentsGenericite superieur #ast;
#ast {
do
    InstanceGenericite^ast := ArgumentsGenericite^ast;
end
}

ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite #ast;
#ast {
do
    SuiteArgumentsGenericite^ast.add(0, ArgumentGenericite^ast);
    ArgumentsGenericite^ast := SuiteArgumentsGenericite^ast;
end
}


SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite #ast;
#ast {
do
    SuiteArgumentsGenericite1^ast.add(0, ArgumentGenericite^ast);
    SuiteArgumentsGenericite^ast := SuiteArgumentsGenericite1^ast;
end
}

SuiteArgumentsGenericite -> #ast;
#ast {
do
    SuiteArgumentsGenericite^ast := new LinkedList<GenericType>();
end
}

ArgumentGenericite -> identificateur_type InstanceGenericite #ast;
#ast {
local
    ot : Optional<Declaration>;
    t  : Type;
    d  : Declaration;
do
    if ArgumentGenericite^tds.knows(identificateur_type^txt) then
        ot := ArgumentGenericite^tds.get(identificateur_type^txt);
        d  := ot.get();
        t  := d.getType();
        ArgumentGenericite^ast := ArgumentGenericite^factory.createGenericType(t, InstanceGenericite^ast);
    else
        error(MiniJava_Type_Error, identificateur_type^txt);
    end
end
}

ArgumentGenericite -> type_bool #ast;
#ast {
do
    ArgumentGenericite^ast := ArgumentGenericite^factory.createGenericType
                                (ArgumentGenericite^factory.createBooleanType(),
                                 new LinkedList<GenericType>());
end
}

ArgumentGenericite -> type_int #ast;
#ast {
do
    ArgumentGenericite^ast := ArgumentGenericite^factory.createGenericType
                                (ArgumentGenericite^factory.createIntegerType(),
                                 new LinkedList<GenericType>());
end
}

ElementsClasse -> DroitAcces ElementClasse #inh ElementsClasse #ast;
#inh {
do
    if !ElementsClasse^tds.contains(ElementClasse^ast.getName()) then
        ElementsClasse^tds.register(ElementClasse^ast);
        ElementsClasse1^tds := ElementsClasse^tds;
    else
          error(MiniJava_ClassElement_Definition, ElementClasse^ast);
    end
end
}
#ast {
do
    ElementsClasse1^ast.add(0,
        ElementsClasse^factory.createClassElement(ElementClasse^ast, DroitAcces^ast)
        );
    ElementsClasse^ast := ElementsClasse1^ast;
end
}

ElementsClasse -> #ast;
#ast {
do
    ElementsClasse^ast := new LinkedList<ClassElement>();
end
}


DroitAcces -> public #ast;
#ast {
do
    DroitAcces^ast := AccessModifier.Public;
end
}

DroitAcces -> protege #ast;
#ast {
do
    DroitAcces^ast := AccessModifier.Protected;
end
}

DroitAcces -> prive #ast;
#ast {
do
    DroitAcces^ast := AccessModifier.Private;
end
}


ElementClasse -> statique AttributOuMethode #ast;
#ast {
do
    -- This method just set bool static to true;
    ElementClasse^ast := ElementClasse^factory.createClassElement(AttributOuMethode^ast, NonAccessModifier.Static);
end
}

ElementClasse -> AttributOuMethode #ast;
#ast {
do
    ElementClasse^ast := ElementClasse^factory.createClassElement(AttributOuMethode^ast);
end
}

ElementClasse -> Constructeur #ast;
#ast {
do
    ElementClasse^ast := ElementClasse^factory.createClassElement(Constructeur^ast);
end
}


AttributOuMethode -> Type identificateur SuiteAttributOuMethode #ast;
#ast {
local
    sam: Object;
do
    if SuiteAttributOuMethode^type = ClassElementType.Attribute then
        if (AttributOuMethode^tds.contains(identificateur^txt)) then
            error(MiniJava_ClassElement_Definition, identificateur^txt);
        else
            if SuiteAttributOuMethode^value = null then
                AttributOuMethode^ast := AttributOuMethode^factory.createVariableDeclaration(identificateur^txt,
                            Type^ast);
            else
                AttributOuMethode^ast := AttributOuMethode^factory.createVariableDeclaration(identificateur^txt,
                            Type^ast, SuiteAttributOuMethode^value);
            end
        end
    else
        AttributOuMethode^ast := AttributOuMethode^factory.createFunctionDeclaration(identificateur^txt,
            Type^ast, SuiteAttributOuMethode^ast, SuiteAttributOuMethode^body);
    end
end
}

AttributOuMethode -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante Bloc #ast;
#ast {
local
    body : FunctionBody;
do
    body := AttributOuMethode^factory.createFunctionBody(Bloc^ast);
    AttributOuMethode^ast := AttributOuMethode^factory.createFunctionDeclaration
    (identificateur^txt, AtomicType.VoidType, Parametres^ast, body);
end
}

SuiteAttributOuMethode -> point_virgule #ast;
#ast {
do
    SuiteAttributOuMethode^type := ClassElementType.Attribute;
    SuiteAttributOuMethode^ast := null;
    SuiteAttributOuMethode^body := null;
    SuiteAttributOuMethode^value := null;
end
}

SuiteAttributOuMethode -> affectation Expression point_virgule #ast;
#ast {
do
    SuiteAttributOuMethode^type := ClassElementType.Attribute;
    SuiteAttributOuMethode^ast := null;
    SuiteAttributOuMethode^body := null;
    SuiteAttributOuMethode^value := Expression^ast;
end
}

--TODO (Parametres must have a new TDS)
--TODO (Bloc must inherit SuiteAttributOuMethode^tds with Parametres^tds included)
SuiteAttributOuMethode -> parenthese_ouvrante Parametres parenthese_fermante Bloc #ast;
#ast {
do
    SuiteAttributOuMethode^type := ClassElementType.Method;
    SuiteAttributOuMethode^ast := Parametres^ast;
    SuiteAttributOuMethode^body := SuiteAttributOuMethode^factory.createFunctionBody(Bloc^ast);
    SuiteAttributOuMethode^value := null;
end
}

Constructeur -> identificateur_type parenthese_ouvrante Parametres parenthese_fermante Bloc #ast;
#ast {
local
    body : FunctionBody;
do
    body := Constructeur^factory.createFunctionBody(Bloc^ast);
    Constructeur^ast := Constructeur^factory.createFunctionDeclaration(
                                        identificateur_type^txt,
                                        new ConstructorTypeImpl(),
                                        Parametres^ast,
                                        body
                                      );
end
}


Parametres -> #ast;
#ast {
do
    Parametres^ast := new LinkedList<ParameterDeclaration>();
end
}

Parametres -> Parametre #inh SuiteParametres #ast;
#inh {
do
    if !Parametres^tds.knows(Parametre^ast.getName()) then
        Parametres^tds.register(Parametre^ast);
        SuiteParametres^tds := Parametres^tds;
    else
          error(MiniJava_Parameter_Definition, Parametre^ast);
    end
end
}
#ast {
do
    SuiteParametres^ast.add(0,Parametre^ast);
    Parametres^ast := SuiteParametres^ast;
end
}


Parametre -> Type identificateur #ast;
#ast {
do
    Parametre^ast := Parametre^factory.createParameterDeclaration(identificateur^txt, Type^ast);
end
}


SuiteParametres -> #ast;
#ast {
do
    SuiteParametres^ast := new LinkedList<ParameterDeclaration>();
end
}

SuiteParametres -> virgule Parametre #inh SuiteParametres #ast;
#inh {
do
    if !SuiteParametres^tds.knows(Parametre^ast.getName()) then
        SuiteParametres^tds.register(Parametre^ast);
        SuiteParametres1^tds := SuiteParametres^tds;
    else
          error(MiniJava_Parameter_Definition, Parametre^ast);
    end
end
}
#ast {
do
    SuiteParametres1^ast.add(0,Parametre^ast);
    SuiteParametres^ast := SuiteParametres1^ast;
end
}


Bloc -> accolade_ouvrante #inh Instructions accolade_fermante #ast ;
#inh {
do
   Instructions^tds :=  new SymbolTable(Bloc^tds);
end
}
#ast {
do
   Bloc^ast := Bloc^factory.createBlock(Instructions^ast);
end
}


Type -> TypeAtomique #inh SuiteTypeAtomique #ast;
#inh {
do
    SuiteTypeAtomique^type := TypeAtomique^ast;
end
}
#ast {
do
    Type^ast := SuiteTypeAtomique^ast;
end
}

TypeAtomique -> type_bool #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createBooleanType();
end
}

TypeAtomique -> type_int #ast;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createIntegerType();
end
}

TypeAtomique -> type_char #ast;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createCharType();
end
}

TypeAtomique -> type_String #ast;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createStringType();
end
}

TypeAtomique -> identificateur_type InstanceGenericite #ast;
#ast {
local
    od : Optional<Declaration>;
    d  : Declaration;
do
    if TypeAtomique^tds.knows(identificateur_type^txt) then
        od := TypeAtomique^tds.get(identificateur_type^txt);
        if od.isPresent() then
            d := od.get();
            if !InstanceGenericite^ast.isEmpty() then
                TypeAtomique^ast := TypeAtomique^factory.createGenericType(
                d.getType(), InstanceGenericite^ast);
            else
                TypeAtomique^ast := d.getType();
            end
        else
            error(MiniJava_Type_Error, identificateur_type^txt);
        end
    else
        error(MiniJava_Type_Error, identificateur_type^txt);
    end
end
}



SuiteTypeAtomique -> crochet_ouvrant crochet_fermant #inh SuiteTypeAtomique #ast;
#inh {
do
    SuiteTypeAtomique1^type := SuiteTypeAtomique^factory.createArrayType(SuiteTypeAtomique^type);
end
}
#ast {
do
    SuiteTypeAtomique^ast := SuiteTypeAtomique^type;
end
}

SuiteTypeAtomique -> #ast;
#ast {
do
    SuiteTypeAtomique^ast := SuiteTypeAtomique^type;
end
}


Instructions -> #ast;
#ast {
do
    Instructions^ast := new LinkedList<Instruction>();
end
}

Instructions -> Instruction Instructions #ast;
#ast {
do
    Instructions1^ast.add(0, Instruction^ast);
    Instructions^ast := Instructions1^ast;
end
}


Instruction -> Type identificateur #inh SuiteAffectation point_virgule
#ast;
#inh {
do
    if (Instruction^tds.contains(identificateur^txt)) then
        error(Bloc_unexpected_token, identificateur^txt);
    end
end
}
#ast {
local
    d: Declaration;
do
    d := Instruction^factory.createVariableDeclaration(identificateur^txt, Type^ast, SuiteAffectation^ast);
    if !Instruction^tds.contains(identificateur^txt) then
        Instruction^tds.register(d);
        Instruction^ast := d;
    else
        error(MiniJava_ClassElement_Definition, identificateur^txt);
    end
end
}

Instruction -> Expression point_virgule #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createVoidInstruction(Expression^ast);
end
}


Instruction -> si parenthese_ouvrante Expression parenthese_fermante Bloc SuiteConditionnelle #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createConditional(Expression^ast, Bloc^ast, SuiteConditionnelle^ast);
end
}

SuiteConditionnelle -> #ast;
#ast {
do
    SuiteConditionnelle^ast := SuiteConditionnelle^factory.createBlock();
end
}

SuiteConditionnelle ->sinon Bloc #ast;
#ast {
do
    SuiteConditionnelle^ast := Bloc^ast;
end
}

--Instructions
Instruction -> tant_que parenthese_ouvrante Expression parenthese_fermante Bloc #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createRepetition(Expression^ast, Bloc^ast);
end
}

Instruction -> afficher Expression point_virgule #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createPrinter(Expression^ast);
end
}

Instruction -> retour Expression point_virgule #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createReturn(Expression^ast);
end
}

--TODO return this
--Instruction -> retour ceci point_virgule #ast;
--#ast {
--do
--    Instruction^ast := Instruction^factory.createReturnThis();
--end
--}

--Expression -> Condition #inh SuiteCondition #ast ;
--#inh {
--do
--   SuiteCondition^gauche := Condition^ast ;
--end
--}
--#ast {
--do
--    Expression^ast := SuiteCondition^ast;
--end
--}
Expression -> Affectation SuiteAffectation #ast;
#ast {
local
    e : Expression;
    d : Declaration;
do
    if SuiteAffectation^ast != SpecialValue.NoValue then
        e := Affectation^ast;
        match e
        with ArrayAccessImpl then
            Expression^ast := Expression^factory.createAssignment(
                                Expression^factory.createArrayAssignment(e), SuiteAffectation^ast);
        with Usage then
            d := e.getDeclaration();
            Expression^ast := Expression^factory.createAssignment(d, SuiteAffectation^ast);
        else
            Expression^ast := Expression^factory.createAssignment(Affectation^ast, SuiteAffectation^ast);
        end
    else
        Expression^ast := Affectation^ast;
    end
end
}

Affectation -> Condition #inh SuiteCondition #ast;
#inh {
do
   SuiteCondition^gauche := Condition^ast ;
end
}
#ast {
do
    Affectation^ast := SuiteCondition^ast;
end
}

SuiteAffectation -> affectation Expression #ast;
#ast {
do
    SuiteAffectation^ast := Expression^ast;
end
}

SuiteAffectation -> #ast;
#ast {
do
    SuiteAffectation^ast := SpecialValue.NoValue;
end
}

--SuiteCondition
SuiteCondition -> Comparatif Condition #ast ;
#ast {
do
	SuiteCondition^ast :=
	SuiteCondition^factory.createBinaryExpression(
	    SuiteCondition^gauche,
	    Comparatif^bin_op,
	    Condition^ast);
end
}

SuiteCondition -> #ast ;
#ast {
do
   SuiteCondition^ast := SuiteCondition^gauche;
end
}

--Comparatif
Comparatif -> egalite #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.Equals;
end
}

Comparatif -> different #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.Different;
end
}

Comparatif -> inferieur #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.Lesser;
end
}

Comparatif -> inferieur_egal #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.LesserOrEqual;
end
}

Comparatif -> superieur #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.Greater;
end
}

Comparatif -> superieur_egal #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.GreaterOrEqual;
end
}


Condition -> Terme #inh SuiteTerme #ast ;
#inh {
do
   SuiteTerme^gauche := Terme^ast;
end
}

#ast {
do
    Condition^ast := SuiteTerme^ast;
end
}

SuiteTerme -> Additif Terme #inh SuiteTerme #ast ;
#inh {
do
   SuiteTerme1^gauche := SuiteTerme^factory.createBinaryExpression(
      SuiteTerme^gauche,
      Additif^bin_op,
      Terme^ast);
end
}

#ast {
do
   SuiteTerme^ast := SuiteTerme1^ast;
end
}

SuiteTerme -> #ast ;
#ast {
do
   SuiteTerme^ast := SuiteTerme^gauche;
end
}


Additif -> addition #ast;
#ast {
do
   Additif^bin_op := BinaryOperator.Add;
end
}

Additif -> soustraction #ast;
#ast {
do
   Additif^bin_op := BinaryOperator.Substract;
end
}

Additif -> ou #ast;
#ast {
do
   Additif^bin_op := BinaryOperator.Or;
end
}


Terme -> Facteur #inh SuiteFacteur #ast ;
#inh {
do
   SuiteFacteur^gauche := Facteur^ast;
end
}

#ast {
do
   Terme^ast := SuiteFacteur^ast;
end
}

SuiteFacteur -> Multiplicatif Facteur #inh SuiteFacteur #ast ;
#inh {
do
   SuiteFacteur1^gauche := SuiteFacteur^factory.createBinaryExpression(
      SuiteFacteur^gauche,
      Multiplicatif^bin_op,
      Facteur^ast);
end
}

#ast {
do
   SuiteFacteur^ast := SuiteFacteur1^ast;
end
}

SuiteFacteur -> #ast;
#ast {
do
   SuiteFacteur^ast := SuiteFacteur^gauche;
end
}

--Multiplicatif
Multiplicatif -> multiplication #ast;
#ast {
do
   Multiplicatif^bin_op := BinaryOperator.Multiply;
end
}

--Multiplicatif
Multiplicatif -> division #ast;
#ast {
do
   Multiplicatif^bin_op := BinaryOperator.Divide;
end
}

Multiplicatif -> modulo #ast;
#ast {
do
   Multiplicatif^bin_op := BinaryOperator.Modulo;
end
}

Multiplicatif -> et #ast;
#ast {
do
   Multiplicatif^bin_op := BinaryOperator.And;
end
}


Facteur -> accolade_ouvrante Expressions accolade_fermante #ast;
#ast {
do
   Facteur^ast := Facteur^factory.createSequence(Expressions^ast);
end
}

Expressions -> Expression SuiteExpressions #ast;
#ast {
do
    SuiteExpressions^ast.add(0, Expression^ast);
    Expressions^ast := SuiteExpressions^ast;
end
}

SuiteExpressions -> virgule Expression SuiteExpressions #ast;
#ast {
do
    SuiteExpressions1^ast.add(0, Expression^ast);
    SuiteExpressions^ast := SuiteExpressions1^ast;
end
}

SuiteExpressions -> #ast;
#ast {
do
    SuiteExpressions^ast := new LinkedList<Expression>();
end
}


Facteur -> soustraction Facteur #ast ;
#ast {
do
   Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Opposite,Facteur1^ast);
end
}

Facteur -> negation Facteur #ast ;
#ast {
do
   Facteur^ast := Facteur ^factory. createUnaryExpression(UnaryOperator.Negate,Facteur1^ast);
end
}

Facteur -> nouveau Type #inh SuiteNouveau #ast ;
#inh {
do
   SuiteNouveau^type := Type^ast;
end
}

#ast {
do
   Facteur^ast := SuiteNouveau^ast;
end
}


Facteur -> ceci #inh AppelOuAcces #ast;
#inh {
do
   AppelOuAcces^support := Facteur^factory.createClassThisUse();
end
}
#ast {
do
    Facteur^ast := AppelOuAcces^ast;
end
}

--TODO chained constructor
--Facteur -> ceci #inh Appel #ast;
--#inh {
--do
--    Appel^support := Facteur^factory.createClassThisUse();
--end
--}
--#ast {
--do
--    Facteur^ast := Appel^ast;
--end
--}

Facteur -> identificateur_type point identificateur #inh AppelOuAcces #ast;
#inh {
local
   ocd : Optional<Declaration>;
   cd : Declaration;
do
   if (Facteur^tds.knows(identificateur_type^txt)) then
       ocd := Facteur^tds.get(identificateur_type^txt);
       cd := ocd.get();
       AppelOuAcces^support := Facteur^factory.createStaticCallOrAccess(cd, identificateur^txt);
   else
       error(MiniJava_Type_not_defined, identificateur_type^txt);
   end
end
}
#ast {
do
    Facteur^ast := AppelOuAcces^ast;
end
}

Facteur -> parenthese_ouvrante Expression parenthese_fermante #ast;
#ast {
do
   Facteur^ast := Expression^ast;
end
}


--TODO(2d array)
SuiteNouveau -> crochet_ouvrant Expression crochet_fermant #ast;
#ast {
do
   SuiteNouveau^ast := SuiteNouveau^factory.createArrayAllocation(SuiteNouveau^type,Expression^ast);
end
}

SuiteNouveau -> #inh Arguments #ast;
#inh {
do
    Arguments^support := SuiteNouveau^factory.createObjectAllocation(SuiteNouveau^type);
end
}
#ast {
do
    SuiteNouveau^ast := Arguments^ast;
end
}


Arguments -> parenthese_ouvrante parenthese_fermante #ast;
#ast {
do
   Arguments^ast := Arguments^factory.createFunctionAccess(Arguments^support);
end
}

Arguments -> parenthese_ouvrante Expressions parenthese_fermante #ast;
#ast {
do
   Arguments^ast := Arguments^factory.createFunctionAccess(Arguments^support, Expressions^ast);
end
}


Facteur -> Valeur #ast;
#ast {
do
   Facteur^ast := Valeur^ast;
end
}


Valeur -> entier #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createIntegerValue(entier^txt);
end
}

Valeur -> vrai #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(true);
end
}

Valeur -> faux #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(false);
end
}

Valeur -> chaine #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createStringValue(chaine^txt);
end
}

Valeur -> caractere #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createCharValue(caractere^txt);
end
}


Facteur -> identificateur #inh AppelOuAcces #ast;
#inh {
local
   f : Optional<Declaration>;
   d : Declaration;
do
   if (Facteur^tds.knows(identificateur^txt)) then
      f := Facteur^tds.get(identificateur^txt);
      d := f.get();
      match d
      with ConstantDeclaration then AppelOuAcces^support := d.getValue();
      with VariableDeclaration then AppelOuAcces^support := Facteur^factory.createVariableUse(d);
      with ClassElementImpl then AppelOuAcces^support := Facteur^factory.createClassElementUse(d);
      with ParameterDeclarationImpl then AppelOuAcces^support := Facteur^factory.createParameterUse(d);
      end
   else
      error(MiniJava_undefined_ident, identificateur^txt);
   end
end
}
#ast {
do
    Facteur^ast := AppelOuAcces^ast;
end
}


AppelOuAcces -> Acces #ast;
#ast {
do
    AppelOuAcces^ast := Acces^ast;
end
}

AppelOuAcces -> Appel #ast;
#ast {
do
    AppelOuAcces^ast := Appel^ast;
end
}


Acces -> #ast ;
#ast {
do
   Acces^ast := Acces^support;
end
}

Acces -> crochet_ouvrant Expression crochet_fermant #inh AppelOuAcces #ast;
#inh {
do
   AppelOuAcces^support := Acces^factory.createArrayAccess(Acces^support,Expression^ast);
end
}

#ast {
do
   Acces^ast := AppelOuAcces^ast;
end
}

Acces -> point identificateur #inh AppelOuAcces #ast;
#inh {
local
    op : Optional<Declaration>;
    ce : Declaration;
    e : Expression;
do
    e := Acces^support;
    match e
    with ClassThisUse then
        if Acces^tds.knows(identificateur^txt) then
            op := Acces^tds.get(identificateur^txt);
            ce := op.get();
            match ce
            with ClassElement then
                AppelOuAcces^support := Acces^factory.createClassElementUse(ce);
            end
        end
    else
        AppelOuAcces^support := Acces^factory.createFieldAccess(Acces^support,identificateur^txt);
    end
end
}

#ast {
do
   Acces^ast := AppelOuAcces^ast;
end
}


--Appel -> parenthese_ouvrante parenthese_fermante #inh AppelOuAcces #ast;
--#inh {
--do
--   AppelOuAcces^support := Appel^factory.createFunctionAccess(Appel^support);
--end
--}
--
--#ast {
--do
--   Appel^ast := AppelOuAcces^ast;
--end
--}
--
--Appel -> parenthese_ouvrante Expressions parenthese_fermante #inh AppelOuAcces #ast;
--#inh {
--do
--   AppelOuAcces^support := Appel^factory.createFunctionAccess(Appel^support, Expressions^ast);
--end
--}
--
--#ast {
--do
--   Appel^ast := AppelOuAcces^ast;
--end
--}

Appel -> #inh1 Arguments #inh2 Acces #ast;
#inh1 {
do
   Arguments^support := Appel^support;
end
}
#inh2 {
do
   Acces^support := Arguments^ast;
end
}
#ast {
do
   Appel^ast := Acces^ast;
end
}

end
