----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--              Gestion de la table des symboles
--              Typage
--              Calcul des déplacements (Allocation mémoire)
--              Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;

inh factory	: BlockFactory for Programme, Interfaces, Interface, Classes, Classe,
              Principale, Instruction, Instructions, Affectable, SuiteAffectable,
              Facteur, SuiteFacteur, Terme, SuiteTerme, Expression, SuiteExpressions,
              Condition, SuiteConditionnelle, ElementInterface, ElementsInterface,
              Signature, Bloc, MethodePrincipale, AttributOuMethode, ElementClasse,
              ElementsClasse, Acces, Appel, AppelOuAcces, SuiteNouveau, Expressions,
              Constructeur, SuiteAttributOuMethode, SuiteCondition, Type,
              TypeAtomique, SuiteTypeAtomique, Parametre, Parametres,
              SuiteParametres, Valeur;
inh tds     : SymbolTable for  Programme, Interfaces, Classes, Principale,
              Instruction, Instructions, Affectable, Bloc, MethodePrincipale,
              AttributOuMethode, SuiteAttributOuMethode, Constructeur, ElementClasse,
              ElementsClasse, Classe, SuiteConditionnelle, Facteur, Terme,
              SuiteTerme, Condition, SuiteFacteur, Expression, SuiteCondition,
              SuiteExpressions, Expressions, SuiteNouveau, Acces, Appel,
              AppelOuAcces, SuiteAffectable, ElementInterface, ElementsInterface,
              Interface;
inh support : Assignable for SuiteAffectable;
inh support : Expression for AppelOuAcces, Appel, Acces;
inh gauche	: Expression for SuiteTerme, SuiteFacteur, SuiteCondition;
inh type    : Type for SuiteTypeAtomique, SuiteNouveau;

syn ast     : Block for Fichier, Programme, Bloc;
syn ast		: Type for Type, TypeAtomique, SuiteTypeAtomique;
syn ast		: Instruction for Instruction;
syn ast     : List<Instruction> for Instructions;
syn ast		: Expression for Expression, Facteur, SuiteFacteur, SuiteNouveau,
              Terme, SuiteTerme, Condition, SuiteCondition, SuiteConditionnelle,
              Acces, Appel;
syn ast     : List<Expression> for Expressions, SuiteExpressions;
syn ast     : Assignable for Affectable, SuiteAffectable, AppelOuAcces;
syn ast     : Value for Valeur;
syn bin_op	: BinaryOperator for Additif, Multiplicatif, Comparatif;

space  separateur				is    "[\n\r\t ]+";
space  commentaire		    	is    "\/\/.*\n";
sugar  accolade_ouvrante		is    "\{";
sugar  accolade_fermante		is    "\}";
sugar  crochet_ouvrant			is    "\[";
sugar  crochet_fermant			is    "\]";
sugar  parenthese_ouvrante		is    "\(";
sugar  parenthese_fermante		is    "\)";
sugar  inferieur				is    "\<";
sugar  superieur				is    "\>";
sugar  inferieur_egal			is    "\<=";
sugar  superieur_egal			is    "\>=";
sugar  point					is    "\.";
sugar  point_virgule			is    ";";
sugar  virgule					is    ",";
sugar  affectation				is    "=";
sugar  egalite					is    "==";
sugar  different				is    "\!=";
sugar  addition			    	is    "\+";
sugar  soustraction				is    "\-";
sugar  ou						is    "\|\|";
sugar  multiplication			is    "\*";
sugar  division			    	is    "/";
sugar  modulo			   		is    "%";
sugar  adresse					is    "&";
sugar  negation			    	is    "\!";
sugar  et						is    "&&";
sugar  vrai			    		is    "true";
sugar  faux			    		is    "false";
sugar  si						is    "if";
sugar  sinon					is    "else";
sugar  afficher					is    "print";
sugar  nouveau			    	is    "new";
sugar  tant_que			    	is    "while";
sugar  retour					is    "return";
sugar  type_int			    	is    "int";
sugar  type_bool				is    "boolean";
sugar  type_float				is    "float";
sugar  type_char				is    "char";
sugar  type_String				is    "String";
sugar vide			    		is    "void";
sugar nul						is    "null";
sugar  choix					is    "\?";
sugar  deux_points				is    ":";
sugar  interface				is    "interface";
sugar  classe					is    "class";
sugar  extension				is    "extends";
sugar  implantation				is    "implements";
sugar public					is    "public";
sugar protege					is    "protected";
sugar prive				    	is    "private";
sugar statique					is    "static";
sugar final				    	is    "final";
sugar principale				is    "main";
term   chaine					is    "\"([^\"]|\\\")*\"";
term   caractere				is    "\'[^\']\'";
term   entier					is    "[0-9]+";
term   identificateur			is    "[a-z_][a-zA-Z0-9_]*";
term   identificateur_type		is    "[A-Z][a-zA-Z0-9_]*";


Fichier -> #inh Programme #ast;
#inh {
do
   Programme^factory := new BlockFactoryImpl();
   Programme^tds := new SymbolTable();
end
}
#ast {
do
    Fichier^ast := Programme^ast;
end
}

Programme -> #inh Interfaces Classes Principale #ast;
#inh {
do
   Interfaces^tds := new SymbolTable(Programme^tds);
   Classes^tds := new SymbolTable(Programme^tds);
   Principale^tds := new SymbolTable(Programme^tds);
end
}
#ast {
do
   Programme^ast := Programme_factory.createProgramAst(
                    Interfaces^ast, Classes^ast, Principale^ast);
end
}


Interfaces -> Interface Interfaces ;

Interfaces -> ;


Interface -> interface identificateur_type Genericite HeritageInterface accolade_ouvrante ElementsInterface accolade_fermante ;


HeritageInterface -> extension identificateur_type InstanceGenericite SuiteHeritageInterface ;

HeritageInterface -> ;


SuiteHeritageInterface -> virgule identificateur_type InstanceGenericite SuiteHeritageInterface ;

SuiteHeritageInterface -> ;


ElementsInterface -> ElementInterface ElementsInterface ;

ElementsInterface -> ;


ElementInterface -> final statique Type identificateur affectation Expression point_virgule ;

ElementInterface -> Signature point_virgule ;


Signature -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante ;

Signature -> Type identificateur parenthese_ouvrante Parametres parenthese_fermante ;


Classes -> Classe Classes ;

Classes -> ;


Classe -> classe  identificateur_type Genericite HeritageClasse ImplantationInterface accolade_ouvrante ElementsClasse accolade_fermante ;


HeritageClasse -> extension identificateur_type InstanceGenericite ;

HeritageClasse -> ;

ImplantationInterface -> implantation identificateur_type InstanceGenericite SuiteHeritageInterface ;

ImplantationInterface -> ;


Principale -> public classe identificateur_type accolade_ouvrante MethodePrincipale accolade_fermante ;


MethodePrincipale -> public statique vide principale parenthese_ouvrante type_String crochet_ouvrant crochet_fermant identificateur parenthese_fermante Bloc ;


Genericite -> inferieur ParametresGenericite superieur ;

Genericite -> ;


ParametresGenericite -> ParametreGenericite SuiteParametresGenericite ;


SuiteParametresGenericite -> virgule ParametreGenericite SuiteParametresGenericite ;

SuiteParametresGenericite -> ;


ParametreGenericite -> identificateur_type HeritageGenericite ;

ParametreGenericite -> choix HeritageGenericite ;


HeritageGenericite -> extension identificateur_type SuiteHeritageGenericite ;

HeritageGenericite -> ;

SuiteHeritageGenericite -> adresse identificateur_type SuiteHeritageGenericite ;

SuiteHeritageGenericite -> ;


InstanceGenericite -> ;

InstanceGenericite -> inferieur ArgumentsGenericite superieur ;


ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite ;


SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite ;

SuiteArgumentsGenericite -> ;


ArgumentGenericite -> identificateur_type InstanceGenericite ;

ArgumentGenericite -> type_String ;


ElementsClasse -> DroitAcces ElementClasse ElementsClasse ;

ElementsClasse -> ;


DroitAcces -> public ;

DroitAcces -> protege ;

DroitAcces -> prive ;


ElementClasse -> statique AttributOuMethode ;

ElementClasse -> AttributOuMethode ;

ElementClasse -> Constructeur ;


AttributOuMethode -> Type identificateur SuiteAttributOuMethode;

AttributOuMethode -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante Bloc ;


SuiteAttributOuMethode -> point_virgule ;

SuiteAttributOuMethode -> parenthese_ouvrante Parametres parenthese_fermante Bloc ;


Constructeur -> identificateur_type parenthese_ouvrante Parametres parenthese_fermante Bloc ;



Parametres -> ;

Parametres -> Parametre SuiteParametres ;


Parametre -> Type identificateur ;


SuiteParametres -> ;

SuiteParametres -> virgule Parametre SuiteParametres ;


Bloc -> accolade_ouvrante #inh Instructions accolade_fermante #ast ;
#inh {
do
   Instructions^tds :=  new SymbolTable(Bloc^tds);
end
}
#ast {
do
   Bloc^ast := Bloc^factory.createBlock(Instructions^ast);
end
}


Type -> TypeAtomique #inh SuiteTypeAtomique #ast;
#inh {
do
    SuiteTypeAtomique^type := Type^factory.createArrayType(TypeAtomique^ast);
end
}
#ast {
do
    Type^ast := SuiteTypeAtomique^ast;
end
}

TypeAtomique -> type_bool #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createBooleanType();
end
}

TypeAtomique -> type_int #ast;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createIntegerType();
end
}

TypeAtomique -> type_char #ast;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createCharType();
end
}

TypeAtomique -> type_float #ast;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createFloatType();
end
}

TypeAtomique -> type_String #ast;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createStringType();
end
}
-- TODO(Genericite)
TypeAtomique -> identificateur_type InstanceGenericite  ;


SuiteTypeAtomique -> crochet_ouvrant crochet_fermant #inh SuiteTypeAtomique #ast;
#inh {
do
    SuiteTypeAtomique1^type := SuiteTypeAtomique^factory.createArrayType(SuiteTypeAtomique^type);
end
}
#ast {
do
    SuiteTypeAtomique^ast := SuiteTypeAtomique^type;
end
}

SuiteTypeAtomique -> #ast;
#ast {
do
    SuiteTypeAtomique^ast := SuiteTypeAtomique^type;
end
}


Instructions -> #ast;
#ast {
do
    Instructions^ast := new ArrayList<Instruction>();
end
}

Instructions -> Instruction Instructions #ast;
#ast {
do
    Instructions1^ast.add(0, Instruction^ast);
    Instructions^ast := Instructions1^ast;
end
}


Instruction -> Type identificateur affectation #inh Expression point_virgule #ast;
#inh {
local
    d: Declaration;
do
    d := Instruction^factory.createVariableDeclaration(identificateur^txt, Type^ast, null);
    if (Instruction^tds.contains(d.getName())) then
        error(Bloc_unexpected_token, identificateur^txt);
    else
        Instruction^tds.register(d);
    end
end
}
#ast {
do
    Instruction^ast := Instruction^factory.createVariableDeclaration(identificateur^txt, Type^ast, Expression^ast);
end
}


Instruction -> Affectable affectation Expression point_virgule #ast ;
#ast {
do
      Instruction^ast := Instruction^factory.createAssignment(Affectable^ast, Expression^ast);
end
}


Affectable -> parenthese_ouvrante Affectable parenthese_fermante #ast ;
#ast {
do
   Affectable^ast := Affectable1^ast;
end
}

Affectable -> identificateur #inh SuiteAffectable #ast ;
#inh {
local
   o : Optional<Declaration>;
   d : Declaration;
do
   if (Affectable^tds.knows(identificateur^txt)) then
      o := Affectable^tds.get(identificateur^txt);
      d := o.get();
      match d
      with VariableDeclaration then SuiteAffectable^support := Affectable^factory.createVariableAssignment( d );
      with ConstantDeclaration then error(BLOC_not_a_variable, identificateur^txt);
      end
   else
      error(BLOC_undefined_ident, identificateur^txt);
   end
end
}

#ast {
do
   Affectable^ast := SuiteAffectable^ast;
end
}


SuiteAffectable -> #ast ;
#ast {
do
   SuiteAffectable^ast := SuiteAffectable^support;
end
}

SuiteAffectable -> point identificateur #inh AppelOuAcces #ast;
#inh {
do
    AppelOuAcces^support := SuiteAffectable^factory.createFieldAssignment(SuiteAffectable^support,identificateur^txt);
end
}
#ast {
do
   SuiteAffectable^ast := AppelOuAcces^ast;
end
}

SuiteAffectable -> crochet_ouvrant Expression crochet_fermant #inh SuiteAffectable #ast ;
#inh {
do
   SuiteAffectable1^support := SuiteAffectable^factory.createArrayAssignment(SuiteAffectable^support,Expression^ast);
end
}

#ast {
do
   SuiteAffectable^ast := SuiteAffectable1^ast;
end
}



Instruction -> si parenthese_ouvrante Expression parenthese_fermante Bloc SuiteConditionnelle #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createConditional(Expression^ast, Bloc^ast, SuiteConditionnelle^ast);
end
}

SuiteConditionnelle -> #ast;
#ast {
do
    SuiteConditionnelle^ast := SuiteConditionnelle^factory.createBlock();
end
}

SuiteConditionnelle ->sinon Bloc #ast;
#ast {
do
    SuiteConditionnelle^ast := Bloc^ast;
end
}

--Instructions
Instruction -> tant_que parenthese_ouvrante Expression parenthese_fermante Bloc #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createRepetition(Expression^ast, Bloc^ast);
end
}

Instruction -> afficher Expression point_virgule #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createPrinter(Expression^ast);
end
}

Instruction -> retour Expression point_virgule #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createReturn(Expression^ast);
end
}

Expression -> Condition #inh SuiteCondition #ast ;
#inh {
do
   SuiteCondition^gauche := Condition^ast ;
end
}
#ast {
do
    Expression^ast := SuiteCondition^ast;
end
}

--SuiteCondition
SuiteCondition -> Comparatif Condition #ast ;
#ast {
do
	SuiteCondition^ast :=
	SuiteCondition^factory.createBinaryExpression(
	    SuiteCondition^gauche,
	    Comparatif^bin_op,
	    Condition^ast);
end
}

SuiteCondition -> #ast ;
#ast {
do
   SuiteCondition^ast := SuiteCondition^gauche;
end
}

--Comparatif
Comparatif -> egalite #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.Equals;
end
}

Comparatif -> different #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.Different;
end
}

Comparatif -> inferieur #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.Lesser;
end
}

Comparatif -> inferieur_egal #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.LesserOrEqual;
end
}

Comparatif -> superieur #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.Greater;
end
}

Comparatif -> superieur_egal #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.GreaterOrEqual;
end
}

--Condition
Condition -> Terme #inh SuiteTerme #ast ;
#inh {
do
   SuiteTerme^gauche := Terme^ast;
end
}

#ast {
do
    Condition^ast := SuiteTerme^ast;
end
}

SuiteTerme -> Additif Terme #inh SuiteTerme #ast ;
#inh {
do
   SuiteTerme1^gauche := SuiteTerme^factory.createBinaryExpression(
      SuiteTerme^gauche,
      Additif^bin_op,
      Terme^ast);
end
}

#ast {
do
   SuiteTerme^ast := SuiteTerme1^ast;
end
}

SuiteTerme -> #ast ;
#ast {
do
   SuiteTerme^ast := SuiteTerme^gauche;
end
}


Additif -> addition #ast;
#ast {
do
   Additif^bin_op := BinaryOperator.Add;
end
}

Additif -> soustraction #ast;
#ast {
do
   Additif^bin_op := BinaryOperator.Substract;
end
}

Additif -> ou #ast;
#ast {
do
   Additif^bin_op := BinaryOperator.Or;
end
}


Terme -> Facteur #inh SuiteFacteur #ast ;
#inh {
do
   SuiteFacteur^gauche := Facteur^ast;
end
}

#ast {
do
   Terme^ast := SuiteFacteur^ast;
end
}

SuiteFacteur -> Multiplicatif Facteur #inh SuiteFacteur #ast ;
#inh {
do
   SuiteFacteur1^gauche := SuiteFacteur^factory.createBinaryExpression(
      SuiteFacteur^gauche,
      Multiplicatif^bin_op,
      Facteur^ast);
end
}

#ast {
do
   SuiteFacteur^ast := SuiteFacteur1^ast;
end
}

SuiteFacteur -> #ast;
#ast {
do
   SuiteFacteur^ast := SuiteFacteur^gauche;
end
}

--Multiplicatif
Multiplicatif -> multiplication #ast;
#ast {
do
   Multiplicatif^bin_op := BinaryOperator.Multiply;
end
}

--Multiplicatif
Multiplicatif -> division #ast;
#ast {
do
   Multiplicatif^bin_op := BinaryOperator.Divide;
end
}

Multiplicatif -> modulo #ast;
#ast {
do
   Multiplicatif^bin_op := BinaryOperator.Modulo;
end
}

Multiplicatif -> et #ast;
#ast {
do
   Multiplicatif^bin_op := BinaryOperator.And;
end
}


Facteur -> accolade_ouvrante Expressions accolade_fermante #ast;
#ast {
do
   Facteur^ast := Facteur^factory.createExpressions(Expressions^ast);
end
}

Expressions -> Expression SuiteExpressions #ast;
#ast {
do
    SuiteExpressions^ast.add(Expression^ast);
    Expressions^ast := SuiteExpressions^ast;
end
}

SuiteExpressions -> virgule Expression SuiteExpressions #ast;
#ast {
do
    SuiteExpressions1^ast.add(Expression^ast);
    SuiteExpressions^ast := SuiteExpressions1^ast;
end
}

SuiteExpressions -> #ast;
#ast {
do
    SuiteExpressions^ast := new ArrayList<Expression>();
end
}


Facteur -> soustraction Facteur #ast ;
#ast {
do
   Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Opposite,Facteur1^ast);
end
}

Facteur -> negation Facteur #ast ;
#ast {
do
   Facteur^ast := Facteur ^factory. createUnaryExpression(UnaryOperator.Negate,Facteur1^ast);
end
}

Facteur -> nouveau Type #inh SuiteNouveau #ast ;
#inh {
do
   SuiteNouveau^type := Type^ast;
end
}

#ast {
do
   Facteur^ast := SuiteNouveau^ast;
end
}

--TODO(2d array)
SuiteNouveau -> crochet_ouvrant Expression crochet_fermant #ast;
#ast {
do
   SuiteNouveau^ast := SuiteNouveau^factory.createArrayAllocation(SuiteNouveau^type,Expression^ast);
end
}

-- SuiteNouveau -> ;


Facteur -> Valeur #ast;
#ast {
do
   Facteur^ast := Valeur^ast;
end
}


Valeur -> entier #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createIntegerValue(entier^txt);
end
}

Valeur -> vrai #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(true);
end
}

Valeur -> faux #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(false);
end
}

Valeur -> chaine #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createStringValue(chaine^txt);
end
}

Valeur -> caractere #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createCharValue(caractere^txt);
end
}


Facteur -> identificateur #inh AppelOuAcces #ast;
#inh {
local
   f : Optional<Declaration>;
   d : Declaration;
do
   if (Facteur^tds.knows(identificateur^txt)) then
      f := Facteur^tds.get(identificateur^txt);
      d := f.get();
      match d
      with ConstantDeclaration then AppelOuAcces^support := d.getValue();
      with VariableDeclaration then AppelOuAcces^support := Facteur^factory.createVariableUse(d);
      end
   else
      error(BLOC_undefined_ident, identificateur^txt);
   end
end
}
#ast {
do
    Facteur^ast := AppelOuAcces^ast;
end
}


AppelOuAcces -> Acces #ast;
#ast {
do
    AppelOuAcces^ast := Acces^ast;
end
}

AppelOuAcces -> Appel #ast;
#ast {
do
    AppelOuAcces^ast := Appel^ast;
end
}


Acces -> #ast ;
#ast {
do
   Acces^ast := Acces^support;
end
}

Acces -> crochet_ouvrant Expression crochet_fermant #inh AppelOuAcces #ast;
#inh {
do
   AppelOuAcces^support := Acces^factory.createArrayAccess(Acces^support,Expression^ast);
end
}

#ast {
do
   Acces^ast := AppelOuAcces^ast;
end
}

Acces -> point identificateur #inh AppelOuAcces #ast;
#inh {
do
   AppelOuAcces^support := Acces^factory.createFieldAccess(Acces^support,identificateur^txt);
end
}

#ast {
do
   Acces^ast := AppelOuAcces^ast;
end
}


Appel -> parenthese_ouvrante parenthese_fermante #inh AppelOuAcces #ast;
#inh {
do
   AppelOuAcces^support := Appel^factory.createFunctionAccess(Appel^support);
end
}

#ast {
do
   Appel^ast := AppelOuAcces^ast;
end
}

Appel -> parenthese_ouvrante Expressions parenthese_fermante #inh AppelOuAcces #ast;
#inh {
do
   AppelOuAcces^support := Appel^factory.createFunctionAccess(Appel^support, Expressions^ast);
end
}

#ast {
do
   Appel^ast := AppelOuAcces^ast;
end
}

end